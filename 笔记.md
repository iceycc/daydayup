## promise
1. 高阶函数 、回调函数
2. 处理异步的方式
3. 发布/订阅
4. promise A+规范解读
5. 实现一个promise:then、all、race、finally、resolve、reject、defer、catch、abort（中断/自写）

## node
1. 

fs文件操作
1. fs文件操作 常用api （异步 + 同步）
2. mkdir创建目录-多级目录创建
3. rmdir删除目录-广度/深度

## stream流的概念
1. 可读流、可写流、双攻流、转化流
   
HTTP: 基于node的全面解析
1. 静态服务器 http-server
2. 缓存的处理
3. 服务器压缩
4. CORS跨越处理
5. 实现文件上传 form-data
6. 实现多语言
7. 图片防盗链 referer
8. 简单的代理
9. 设置cookie，签名cookie sha256
10. 设置session

## KOA
1. 手写KOA。洋葱模型、中间件的实现
2. koa-bodyParser 请求体的解析 中间件的实现
3. koa-static 实现静态文件中间件的实现
4. koa-views  实现模板引擎
5. koa-router
6. koa-multer
7. koa-session

## 第三方包
1. path-to-regexp

## express  
1. 手写一个 express,内部实现了好多中间件
   1. 路由机制
   2. 中间件机制
   3. 错误处理机制
   4. 多级路由
   5. 路径参数
   6. app.param
   7. res.send()  // 封装了 res.end() 会对数字 字符串 对象等进行了处理。res.end()只支持字符串额
2. express.static()
3. express multer 解析文件上传 https://www.npmjs.com/package/multer
   1. 文件拖拽上传
4. express set cookie-parser
5. express express-session  
    

## cookie

## session

JWT
1. 是什么 优点 怎么做
// jwt-simple jsonwebtoken




## vue





## react
1. jsx
2. react-dom的render函数的简单实现
3. ast
4. 什么是纯函数 、 纯组件
5. 组件的状态和属性
6. 函数组件
7. 类组件
   1. 更新state的方法
8. hasOwnProperty
9. this.setState是异步还是同步 原理
10. 什么是受控组件 什么是非受控组件
11. 如何获取dom
12. <></> = React.Fragment 代码片段
13. ref的使用：原生react组件input 、自定义组件(类组件和函数组件的区别)
14. React.forwardRef()
15. react是单向数据流 如何理解 ：只能从父 给 子 不能反过来
16. 子组件如果改变父组件的状态 props回调
17. 什么是脏组件
18. 旧生命周期
    1.  初始化 Initialization
    2.  装载 Mounting
    3.  更新 Updation
        1.  属性更新props
        2.  状态更新states
    4. 卸载 Unmounting
19. 请求数据为什么在componentDidMount调用？？https://blog.csdn.net/ky1in93/article/details/81362442
20. 新版的生命周期新增了什么，踢出了什么。
21. react中Content上下文是啥
22. ContentApi新版和旧版的用法，新版如何简单实现
23. PureComponent??  mome
24. 什么是高阶组件?手写一个logger高阶组件
25. 高阶组件多层嵌套也是hooks解决的问题之一
26. React.Fragment
27. render props
28. ReactDOM.createPortal(child, container) 将子节点渲染到父组件之外的dom节点
29. HOC
30. 错误边界 componentDidCatch 
31. Suspense
32. react-catch
33. React.Lazy


## react hooks
1. useState
2. useEffect
3. useCallback
4. useMemo
5. useReducer
6. useRef
7. useImperativeHandle
8. useLayoutEffect
9. useLayoutEffect =》return =》useEffect
10. 自己实现 useLogger 、useThunk、usePromise、useAjax

## 项目配置
``` js
create-react-app zhufeng_tract
yarn add customize-cra react-app-rewired --dev // 增强配置
```

config-overrides.js
```js
const {
 override,
 addDecoratorsLegacy,
} = require("customize-cra");
module.exports = override(
 addDecoratorsLegacy(),
);
```

jsconfig.json
```json
{
 "compilerOptions": {
     "experimentalDecorators": true
 }
}
```
## redux
1. let store = createStore(reducer)
   1. getState
   2. dispatch
   3. substribe
   4. unsubstribe
2. bindActionCreators 
3. combineReducers 合并


## mobx
1. create-react-app 配置装饰器https://www.jianshu.com/p/103f004aa41c
2. bindActionCreators
3. redux-mobx
4. react-redux
5. redux中间件 
6. 中间件 applyMiddleware 源码 、洋葱模型
7. compose函数 类比koa  compose(a,b)(x)  (x)=>b=>a
8. redux-logger
9. redux-thunk https://zhuanlan.zhihu.com/p/85403048

## 函数式编程

## 编译原理

## GraphQL

## JS
1. JS最新基本数据类型:BigInt https://segmentfault.com/a/1190000019912017?utm_source=tag-newest


## ts
1. strictNullChecks: null严格检查。函数可选参数兼容
2. strictPropertyInitialization： 初始化参数兼容。和strictNullChecks设置为false时该项也变成false了



## webpack
1. require.context('./examples', true, /\.js$/) // 动态读取文件



## 软件开发
1. 软件生命周期
2. 软件开发模型
   1. 普遍模型
   2. 增量开发模型
   3. 原型开发模型
3. 模型  UML （unified Modeling Language）
   1. 简化、多视角、通用符合
   2. http://staruml.io/
   3. 类图
      1. 属性
      2. 方法
      3. 依赖
      4. 泛化、继承=》由具体到宽泛 extend
      5. 接口 interface
      6. 组合关系：汽车和汽车轮子
      7. 聚合关系：汽车队和汽车
   4. 活动图
   5. 时序图
   6. 协作图
   7. 组件图
   8. 部署图
## 设计模式
1. 单例：
   1. 一般单例
   2. 透明单例
   3. 构建和单例分离 
   4. commonjs的模块化就是用的单例
   5. jquery也用到了单例 全局就一个
   6. 全局模态框
   7. reducer store单例
   8. 缓存一定要单例
2.  适配器模式
   9.  axios兼容浏览器和node服务端
   10. 文件读取 的promise化
   11. computed也是适配器函数
   12. 地址码值表的适配
   13. NodeJs ORM sequelize
3. 装饰器模式  注解 aop
   1. 不改变原来的结构和功能 为对象新增
   2. core-decorators
   3. 应用：    
      1. AOP   
      2. 无痕埋点
      3. 高阶组件 
      4. react-redux 
      5. 表单校验
4. 代理模式
   1. 事件委托
   2. 代理服务器：处理图片、静态资源
   3. 虚拟代理 图片懒加载
   4. 缓存代理 空间换时间 阶乘算法优化
   5. 防抖节流
      1. 节流 只有一个定时器，只认第一个结果
      2. 防抖 每次都重制定时器  只认最后一个结果
   6. 反向代理
   7. 反向代理
5. 观察者模式
   1. Subject 《=》observer
   2. 只有发布者和观察者（两者耦合）
   3. 场景
      1. 事件绑定
      2. Promise
      3. Jquery的 $.callbacks()
      4. events on emit subject
      5. fs.createReadStream on('data') on('end')
      6. http.createServer on('request')  listen(3000)
      7. 生命周期 更新
      8. EventBus
      9. Mvvm中用到了观察者模式。更新页面
      10. reducer
6. 发布订阅模式：中间有个事件中心，
   1. Publisher ==》Event Channel 《==》Subscriber
   2. 中介
7. 外观模式 门面模式   
   1. 子系统
   2. 场景
      1. 计算器
      2. 计算机
      3. 压缩
         1. .gz
         2. .zip
         3. .7z
      4. redux
      5. 函数的重载 
         1. react-createElement
         2. vue-createElement
         3. buffer
         4. createStore
         5. axios node+XML 类似适配器
         6. polyfill jq处理兼容性
8. 迭代器模式
   1. createIterator
   2. forEach
   3. Iterator
      1. Es6中列表类型的列表方法都有 [Symbol.iterator]
   4. yield
## 

## 面向对象
1. 软件开发经历分析、设计和编码三个阶段：
   1. OOA
   2. OOD
   3. OOP
2. 特性
   1. 抽象
   2. 封装
   3. 多态
