是因为 eventloop啊，设置批量更新标识为 true，然后执行完再设置为 false，但是setTimeout比同步代码后执行，所以就执行时已经变成了不批量更新
刘焕
6666
况#296#
好滴
476-刘欢
为什么children要打平?这样不会导致深层节点变为parent的子集了么?
刘蒙蒙
现在好像基本只有大厂用react
赵繁#670#
children是递归，数组是打平
楚小风
vue 中的事件处理也是这样的吗
listentolife
打平只是对嵌套的数组，parent的子组件在对象里
#755#吴永辉
不是
一江西流#682#
不是
heroliang
叔叔节点
陈旭东 #772#
不是
#755#吴永辉
是兄弟节点吧
一江西流#682#
兄弟
陈旭东 #772#
应该是同级的
陈旭东 #772#
A B 才是 div 的子节点
路笃腾#422#
没有父子关系 所以打平了吧
王鑫
是兄弟节点 但是 key不一样
吃饱了
跟周三讲的mapchildren应该同理 要打平
476-刘欢
ok
陈旭东 #772#
如果是父子的关系，就会写成 嵌套格式了<div><span></span></div> 
21:14
一江西流#682#
syntheticEvent.currentTarget = target
21:18
heroliang
35行 creatSyntheticEvent 不是一个function  吗?
蜗牛477
createSyntheticEvent貌似就是拷贝了一下原生事件而已？
路笃腾#422#撤回了一条消息
路笃腾#422#
document.addEventListener 是不是可以提出去
476-刘欢
销毁时直接syntheticEvent={}不行么?
蜗牛477
这样不同的事件会不会串？
listentolife
直接={}相当于重新创建了一个对象吧，现在这样写就是为了直接复用对象，减少创建跟销毁
雨桥明夜
合成事件为什么不能支持，比如防抖之类绑定后的函数
况#296#
异步调用事件，就会有问题，得e.persist()
雨桥明夜
不是很明白，还没用过persist
况#296#
只知道解决办法 ，不明白为啥同步可以，异步不可以…
况#296#
哦哦 讲了…
王鑫
是每次调用完，就销毁吗？那每次点击事件都在创建一个新的event？
阿黄黄黄黄
这奇葩需求 。。。
一江西流#682#
复用了的
一江西流#682#
只是属性值设置null了
吃饱了
切断对象引用 是这样吗
谢冰
以前觉得好神秘，原来这么简单。。。牛逼得写代码就这么高深
我要胖十斤
有点没听懂
王鑫
看下  getSyntheticEvent 
橙树绿
不是很明白 
一佳
见过
#345#
persist之后怎么销毁啊？
#345#
难道一直存在？
#345#
这样会不会有内存溢出的风险？
赵繁#670#
他觉得那个池没用？陈浩强把那个池都分析透了
谢冰
函数运行完了就销毁了
#345#
陈浩强是谁？
赵繁#670#
609号拳手
赵繁#670#
哈哈哈
listentolife
说我吗？
李子维
没引用自己写的 react
吃饱了
没改成自己的
赵繁#670#
你咋不加学号呢，哈哈
listentolife
哈哈，待会上完课再改
listentolife
估计react又找到更好的方案不用对象池了，像这合成事件的实现一样，一直复用一个对象，池都不用了
李子维
老师，要等原生事件冒泡到 document 后，才会再次从 target 用“合成事件”模拟冒泡上来，对吗？所以会比原生 event 慢。
路笃腾#422#撤回了一条消息
李子维
那岂不是经常触发。。
路笃腾#422#
addEventListener是可以执行多次的
会的，但是这是正常的
document.addEventListener 是不是可以提出去 如果不提出去 多个元素绑定同一个事件会不会多次触发 这样是不是有问题
#886#
此刻如果button的父元素上也有onClick事件，岂不是父元素上的onClick事件也会触发
对的
路笃腾#422#
不会 会判断target
吃饱了
源生的也是会触发的 原生就 这样的

#886#撤回了一条消息
吃饱了
你点子元素也会触发父元素的点击事件

我每次点击一下，就会新生成一个 合成事件对象吗，那不是很浪费性能？
雨桥明夜
防抖
onClick={_.debounce(this.handleClick)} 会点击无效，不知道什么原因
李子维
冒泡 和捕获是浏览器的行为
合成事件是不是只有冒泡？
李子维
没有捕获？
李子维
persist 再讲一下。。
476-刘欢
再简略捋一遍?
楚小风
复用一个对象那里
#886#
document的事件委托呢


不太理解子节点点击冒泡的时候怎么触发父节点的事件的
 target = target.parentNode;
Juliana
单例
#345#
在哪里拿到父节点的回调的？
我要胖十斤
正常来说执行完函数之后合成事件对象要回收。但是如果执行persist方法后，就不回收了。再创建一个新的来用
persist还是没理解
王鑫
每次点击，把当前原生事件对象拷贝到合成事件对象上
彭嘻嘻#1050
target = target.parentNode
王鑫
执行完后再把合成事件对象变为空对象
路笃腾#422#
多次触发 click 不会多次执行 事件处理函数吗
人生若只如初见
不是原生的这个React实现 
persist是原生event的？
口袋
onClick = {this.xxx()}  xxx(){console.log(111);return funtion(){}}  这里是闭包;   为什么每次点击都会log 111
一江西流#682#
并不是控对象，只是属性值变为了空，属性还在
李子维
懂了
王鑫
子元素触发事件，父元素页触发，能不能实现看下
一江西流#682#
明白了
王鑫
那它还能被清掉吗？


循环找爹
我要胖十斤
一开始清楚的时候它的persist属性不是没清楚掉么？那这个对象为什么没有了啊
一佳
引用改变了
吃饱了
重新赋值 就切断了原对象的引用了 清空的是新对象
槑
组件中的listener bind  this，这里的this和listener.call(target)的target是同一个人吗
一江西流#682#
清的不是同一个
路笃腾#422#
如果 只想在父节点 点击的时候才执行 父节点的逻辑 点了 子节点 触发了是不是 有问题
listentolife
好像react的map的实现现在全改了，就一个递归函数把之前的逻辑写完了， 所以不需要context对象来存，就去掉对象池了
一江西流#682#
那你要阻止冒泡就好了
justdoitwell
一旦我们调用persist是不是就意味着我们需要持久 化，不能让浏览器回收此对象
回收垃圾的就交给用户自己处理
洗衣机多了，不就泄露了吗
路笃腾#422#
我知道了 现在写的逻辑 正常的 都是冒泡上去的 
王鑫
react 抹平了哪些浏览器差异，处理了哪些不同点
刘蒙蒙
不是
let obj = {a:1};//地址1
obj = {b:2};//地址2
1号对象和2号对象不应该是同一个地址么
路笃腾#422#
绕进去了
李子维
。。。
一江西流#682#
比如IE是attachEvent
路笃腾#422#
老师 没明白我的意思。。
李子维
调用 persist 的时候不是已经清理过了么
加菲#654#撤回了一条消息
刘焕
a = b = {}; a = null ;  差不多就这意思

let obj1 = {};
obj1.a = 1;
obj1 = {};

