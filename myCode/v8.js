// resident set  rss所有内存占用、包括指令区和堆栈
// 代码区域 code segment
// 栈（stack）本地变量、指针
// heapTotal 总的堆，对象、闭包
// heapUsed 使用到的堆。越来也大会造成泄露


console.log(process.memoryUsage())
// { rss: 19566592,
//     heapTotal: 6537216,
//     heapUsed: 3943328,
//     external: 8272 }
let a = {name:'zzzzzzzz'}
let b = '11111111111111111111111'

// V8的垃圾回收机制
// 1. V8是基于分代的垃圾回收机制
// 2. 不同带垃圾回收机制也不一样
// 3. 按存活的时间分为新生代和老生代

// 新生代Form + To：  --max-new-space-size = 32mb
// 老生代： --max-old-space-size =1400mb



// 新生代垃圾回收机制 GC
// 1- 新生代区域一分为二，每个16M，一个使用，一个空闲
// 2- 开始垃圾回收的时候，会检查FROM区域中存活对象，如果还活着，拷贝到TO空间，完成后释放空间
// 3- 完成后 From 和 To 互换
// 4- 新生代扫描的时候是一种广度优先的扫描策略
// 5- 新生代的空间小，存活对象少
// 6- 当一个对象经历过多次的垃圾回收依然存活的时候，生存周期比较长的对象会被移动到老生代
    // 这个移动过程被称为晋升或者升级
        // 经过5次以上的回收还存在，就会放到老生代里
        // TO空间使用占比超过25%，或者超大对象。会放到老生代里


// 对象在堆里
function a(){
    let a1 = {}
    function b(){
        let b1 = {}
        function c(){
            let c1 = {}
        }
        c()
    }
    b()
}
a() // 全局执行上下文

// 如果判断对象是活的还是死的

// 引用计数
// 语言引擎有一张表，保存了内存所有资源的引用次数
// 如果一个值的引用次数是0，表示这个值不再用到了，因此将这块内存释放


let objB = {}
let objC = {}
let objF = {}
let objE = {
    objF
}
// GC root
// window
global.objA = {
    objB,
    objC
}


// 堆和栈怎么联系的

// 栈内存很小 基本不需要回收


// 垃圾回收的机制

// 新生代GC
// 扫描过程是一个广度优先的过程
// 扫描指针：当前 
// 分配指针：当前指针的后一个



// 老生代
// mark-sweep 标记清除。效率高，但是会产生内存碎片
// mark-compact 标记整理,活的向左移动，死的向右移动。效率低，但是不会产生内存碎片
// 老生代空间大，大部分都是活的对象，GC耗时时间比较长
// 在GC期间无法响应，STOP-THE-WORLD

// 三种垃圾回收算法
// mark-sweep 中等速度 空间开销少 不用移动
// mark-compact 最慢 空间开销少 需要移动对象
// scavenge ： 最快，双倍空间 无碎片 需要移动对象 （新生代）

// mark-compact 需要移动对象，执行速度不快，V8主要用mark-sweep
// 1. 空间不足 2 对从新生代升级过来的对象 =》才会使用mark-compact

