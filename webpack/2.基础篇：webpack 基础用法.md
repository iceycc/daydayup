## 基本配置

### webpack 配置组成

```js
module.exports = {
  entry: './src/index.js', // 打包入口文件（指定默认的 entry 为： ./src/index.js）
  output: './dist/main.js', // 打包的输出（指定默认的 output 为： ./dist/main.js）
  mode: 'production', // 环境
  module: { 
    rules: [ // loader配置
      { 
        test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  },
  plugins: [ // 插件配置
    new HtmlwebpackPlugin({
      template: './src/index.html’
    })
  ]
};
```

script脚本

```json
{
  "name": "hello-webpack",
  "version": "1.0.0",
  "description": "Hello webpack",
  "main": "index.js",
  "scripts": {
    "build": "webpack" // 模块局部安装会在 node_modules/.bin ⽬录创建软链接
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

## 核心概念

### Entry

 依赖图的入口，对于⾮代码⽐如图⽚、字体依赖也会 不断加⼊到依赖图中。

![image-20210823090918581](/Users/bingyang/Documents/Project/daydayup/webpack/images/image-20210823090918581.png)

- 单入口：是一个字符串

- 多入口：是一个对象

### Output

编译后的文件如何输出到磁盘

- 单入口：

  ```js
  module.exports = {
    entry:'./src/index.js',
    output:{
  		filename:'bundle.js',
      path:'./dist'
    }
  }
  ```

- 多入口

  ```js
  module.exports = {
      entry: {
          index: './src/index.js',
          search: './src/search.js'
      },
      output: {
          path: path.join(__dirname, 'dist'), 
          filename: '[name].js' // 通过占位符确保⽂件名称的唯⼀
      },
  }
  ```

  

### Loaders

weback开箱支持js和json，通过loaders支持其他文件类型转换成有效模块，并添加到依赖图。

本身是一个函数，接受原文件作为参数，返回转换的结果。

- 对资源进行转换
- 可以在import或者load某个文件进行预处理
- loaders类似其他构建工具的task，提供了前端构建步骤
- 将不同语言（ts）转换成javascript
- 将内联图像转换成data url
- 允许在js中import css文件
- 。。。

常⻅的 Loaders 有哪些？

- babel-loader ：转换es6、es7等语法。
- css-loader、less-loader、sass-loader
- file-loader
- url-loader：图片字体的打包
- ts-loader
- raw-loader：文件以字符串的相识倒入
- thread-loader：多进程打包js和css

loader的用法：

```js
module.exports = {
  module:{
    rules:[
      test:/.\txt$/, // 制定匹配规则
      use:'raw-loader' // use制定loader名称
    ]
  }
}
```



### Plugins

插件用于对bundle文件的优化，资源管理和环境变量注入等，作用于整个构建流程

常见的plugins

- CommonsChunkPlugin 将chunks相同的模块代码提取成公共js
- CleanWebpackPlugin 清空构建目录
- ExtractTextWebpackPlugin 将css从bundlejs提取成单独文件
- CopyWebpackPlugin 将文件或目录拷贝到输出目录
- HtmlWebpackPlugin 创建html文件承载输出到bundle
- UglifyjsWebpackPlugin 压缩js
- ZipWebpackPlugin 将输出资源打包成zip文件

用法：

```js
module.exports = {
    plugins: [
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpackPlugin({
            template: path.join(__dirname, 'src/index.html'),
            filename: 'index.html',
            chunks: ['index'],
            inject: true,
            minify: {
                html5: true,
                collapseWhitespace: true,
                preserveLineBreaks: false,
                minifyCSS: true,
                minifyJS: true,
                removeComments: false
            }
        })
    ],
}
```

### Mode

指定当前构建环境是 production 、development 还是none

设置mode可以使用webpack的内置函数，默认是prodction

mode的内置函数

| 选项        | 描述                                                         |
| :---------- | ------------------------------------------------------------ |
| development | 会将 `DefinePlugin` 中 `process.env.NODE_ENV` 的值设置为 `development`. 为模块和 chunk 启用有效的名。 |
| production  | 会将 `DefinePlugin` 中 `process.env.NODE_ENV` 的值设置为 `production`。为模块和 chunk 启用确定性的混淆名称，`FlagDependencyUsagePlugin`，`FlagIncludedChunksPlugin`，`ModuleConcatenationPlugin`，`NoEmitOnErrorsPlugin` 和 `TerserPlugin` 。 |
| none        | 不使用任何默认优化选项                                       |

如果想根据mode输出不同的配置，可以输出一个函数，而不是对象

```js
var config = {
  entry: './app.js',
  //...
};

module.exports = (env, argv) => {
  if (argv.mode === 'development') {
    config.devtool = 'source-map';
  }

  if (argv.mode === 'production') {
    //...
  }

  return config;
};

```



## 案例

### 解析es6 、react jsx

使用babel-loader

```js
module.exports = {
    module: {
        rules: [
            {
                test: /.(js|jsx)$/,
                use: 'babel-loader'
            }
        ]
    },
};

```

babel配置文件`.babelrc`

```json
{
    "presets": [
        "@babel/preset-env",
      	"@babel/preset-react"
    ],
    "plugins": [
        "@babel/proposal-class-properties" // 一些通过polyfil无法模拟的需要插件支持吧
    ]
}
```

### 解析CSS

```js
module.exports = {
    module: {
        rules: [
            {
                test: /.css$/,
                use: [
                  'style-loader', // 将样式通过 <style> 标签插⼊到 head 中
                  'css-loader' // ⽤于加载 .css ⽂件，并且转换成 commonjs 对象
                ]
            }
        ]
    },
};
```

### 解析Less和Sass

```js
module.exports = {
    module: {
        rules: [
            {
                test: /.less$/,
                use: [
                  'style-loader', // 将样式通过 <style> 标签插⼊到 head 中
                  'css-loader', // ⽤于加载 .css ⽂件，并且转换成 commonjs 对象
                  'less-loader' // ⽤于将 less 转换成 css
                ]
            },
            {
                test: /.scss$/,
                use: [
                  'style-loader', // 将样式通过 <style> 标签插⼊到 head 中
                  'css-loader', // ⽤于加载 .css ⽂件，并且转换成 commonjs 对象
                  '{
                    loader: "sass-loader",
                    options: {
                      // Prefer `dart-sass` // 使用dart-sass
                      implementation: require("sass"),
                    },
                  },
                ]
            }
        ]
    },
};
```

### 解析图⽚

```js
module.exports = {
    module: {
        rules: [
            {
                test: /.(png|jpg|jpeg|gif)$/,
                use: [
                  'file-loader', // 处理文件
                ]
            },
          	// 或
            {
                test: /.(png|jpg|jpeg|gif)$/,
                use: [
                  {
                    loader:'url-loader', // url-loader 也可以处理图⽚和字体
                    options:{
                      limit: 10240 // 可以设置较⼩资源⾃动 base64
                    }
                  }
                ]
            }
        ]
    },
};
```

### 解析字体

```js
module.exports = {
    module: {
        rules: [
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/,
                use: [
                  'file-loader', // 处理文件 或者url-loader
                ]
            }
        ]
    },
};
```

### ⽂件监听

源码发生变化，自动重新构建出新的输出文件

webpack两种开启模式

- 启动命令增加 --watch参数  `"watch": "webpack --watch"` 。缺点：每次需要⼿动刷新浏览器

  ```json
  "scripts": {
    "build": "webpack ",
    "watch": "webpack --watch"
  }
  ```

  

- 配置webpack.config.js设置watch:true

  ```js
  module.export = {
    //默认 false，也就是不开启
    watch: true,
    //只有开启监听模式时，watchOptions才有意义
    wathcOptions: {
      //默认为空，不监听的文件或者文件夹，支持正则匹配
      ignored: /node_modules/,
      //监听到变化发生后会等300ms再去执行，默认300ms
      aggregateTimeout: 300,
      //判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次
      poll: 1000
    }
  }
  ```

  

#### ⽂件监听的原理分析

轮询判断⽂件的最后编辑时间是否变化

### 热更新 HMR：

#### webpack-dev-server

- WDS 不刷新浏览器

- WDS 不输出⽂件，⽽是放在内存中

- 使⽤ HotModuleReplacementPlugin插件

  ```json
  "dev": "webpack-dev-server --open"
  "dev": "webpack server --open" // webpack5
  ```

  

#### 使⽤ HotModuleReplacementPlugin插件

- WDM 将 webpack 输出的⽂件传输给服务器
- 适⽤于灵活的定制场景

```js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-devmiddleware');
const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);
app.use(webpackDevMiddleware(compiler, {
	publicPath: config.output.publicPath
}));
app.listen(3000, function () {
	console.log('Example app listening on port 3000!\n');
});
```

#### 热更新的原理分析

- Webpack Compile: 将 JS 编译成 Bundle
- HMR Server: 将热更新的⽂件输出给 HMR Rumtime
- Bundle server: 提供⽂件在浏览器的访问
- HMR Rumtime: 会被注⼊到浏览器， 更新⽂件的变化
- bundle.js: 构建输出的⽂件
- ![image-20210823105933311](/Users/bingyang/Documents/Project/daydayup/webpack/images/image-20210823105933311.png)

### ⽂件指纹

打包后输出的⽂件名的后缀

![image-20210823110202358](/Users/bingyang/Documents/Project/daydayup/webpack/images/image-20210823110202358.png)

#### ⽂件指纹如何⽣成

- Hash：和整个项⽬的构建相关，只要项⽬⽂件有修改，整个项⽬构建的 hash 值就会更改。

- Chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会⽣成不同的 chunkhash 值
- Contenthash：根据⽂件内容来定义 hash ，⽂件内容不变，则 contenthash 不变

#### js文件指纹的设置

设置 output 的 filename，使⽤ [chunkhash]

```js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
 		filename: '[name][chunkhash:8].js',
 		path: __dirname + '/dist'
  }
};
```



#### CSS 的⽂件指纹设置

设置 MiniCssExtractPlugin 的 filename， 使⽤ [contenthash]

```js
module.exports = {
  entry: {
  app: './src/app.js',
  search: './src/search.js'
  },
  output: {
    filename: '[name][chunkhash:8].js',
    path: __dirname + '/dist'
  },
  plugins: [
     new MiniCssExtractPlugin({
       filename: '[name][contenthash:8].css' // CSS 的⽂件指纹设置
     });
  ]
}
```

#### 图⽚的⽂件指纹设置

设置 file-loader 的 name，使⽤ [hash]

<img src="/Users/bingyang/Library/Application Support/typora-user-images/image-20210823110614296.png" alt="image-20210823110614296" style="zoom: 50%;" />

```js
const path = require('path');
module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    },
    module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          {
            loader: 'file-loader’,
             options: {
               name: 'img/[name][hash:8].[ext] '
             }
          }
        ]
      }
    ]
  }
};
```

### 代码压缩

#### html压缩

修改 html-webpack-plugin，设置压缩参数

```js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name][chunkhash:8].js',
    path: __dirname + '/dist'
  },
  plugins: [
    + new HtmlWebpackPlugin({
      + template: path.join(__dirname, 'src/search.html’),
      + filename: 'search.html’,
      + chunks: ['search’],
      + inject: true,
      + minify: {
        + html5: true,
        + collapseWhitespace: true,
        + preserveLineBreaks: false,
        + minifyCSS: true,
        + minifyJS: true,
        + removeComments: false
      + }
    + })
  ]
};
```



#### js压缩

内置了 uglifyjs-webpack-plugin

#### css压缩

使⽤ optimize-css-assets-webpack-plugin

同时使⽤ [cssnano ](https://www.cssnano.cn/docs/introduction), 能为你的 CSS 文件做多方面的的优化， 以确保最终生成的文件 对生产环境来说体积是最小的。

```js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name][chunkhash:8].js',
    path: __dirname + '/dist'
  },
  plugins: [
   new OptimizeCSSAssetsPlugin({
     assetNameRegExp: /\.css$/g,
     cssProcessor: require('cssnano’)
   })
  ]
};
```